%\VignetteIndexEntry{Bar, Surface and Related Plots}
\documentclass{article}
\usepackage[a4paper,top=2.6cm,bottom=3.6cm,left=3.6cm,right=3.6cm]{geometry}
\usepackage{parskip,verbatim,amsmath,amssymb,color}
\usepackage[nogin]{Sweave}
\pagestyle{myheadings}
\setlength{\parskip}{0.28cm}
\DefineVerbatimEnvironment{Sinput}{Verbatim}{xleftmargin=0.75em, formatcom=\color{rin}}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{xleftmargin=0.75em,formatcom=\color{rout}}
\DefineVerbatimEnvironment{Serror}{Verbatim}{xleftmargin=0.75em,formatcom=\color{rerr}}
\newcommand {\stitle}[3]
{	\title {\vspace {-0.6cm} {\normalsize #1 #2} \\[0.8cm] {\textbf {\huge #3} } }
	\author {\textbf {Abby Spurdle} }
	\maketitle
	\markright{Spurdle, A.\hfill #1 #2\hfill}
	\thispagestyle {empty}
}
\newcommand {\sabstract}[1]
{	\begin {center}
	\begin {minipage}{14.25cm}
		{\textsl {#1} }
	\end {minipage}
	\end {center}
	\vspace {0.06cm}
}
\definecolor{rin}{rgb}{0, 0, 0.32}
\definecolor{rout}{rgb}{0, 0.14, 0}
\definecolor{rerr}{rgb}{0.5, 0.025, 0}
\SweaveOpts{keep.source=TRUE}
\SweaveOpts{eps=FALSE}
\SweaveOpts{prefix.string=temp-bivariate}
\begin{document}

<<echo=false>>=
options(continue=" ")
options(SweaveHooks=list(fig=function()
par(mar=c(4.1, 4.1, 2.6, 1.6), cex=0.7, cex.main=1)))
@

\stitle {barsurf}{0.3.1}{Bar, Surface and Related Plots}

\sabstract {Produces heat maps, contour plots, bar plots (in 3D) and surface plots (also, in 3D). Is designed for plotting functions of two variables, however, can plot relatively arbitrary matrices. Uses HCL color space, extensively. Also, supports triangular plots and nested matrices.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section* {Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This is a relatively minimal R package for mathematical and statistical graphics.

Currently, it contains six main plotting functions:
\begin {itemize}
	\item plot2d.cell()
	\item plot2d.contour()
	\item plot2d.tricontour()
	\item plot3d.bar()
	\item plot3d.surface()
	\item plot3d.trisurface()
\end {itemize}

The functions plot2d.cell() and plot3d.bar() are designed for functions over a discrete rectangular domain, however, can also be used for relatively small but otherwise arbitrary (integer and numeric) matrices, and bivariate categorical data.

The functions plot2d.contour() and plot3d.surface() are designed for functions over a continuous rectangular domain. And the functions plot2d.tricontour() and plot3d.trisurface() are designed functions over a continuous triangular domain.

The function plot2d.cell() produces a heat map. By default, the functions plot2d.contour() and plot2d.tricontour produce contour plots with heat maps. The 3D plots use orthographic projection (rather than perspective projection) and currently, use a fixed viewing angle (so, you can't rotate the plots).

All the plots use colors defined in HCL color space.

All of these functions require at least one argument, z. In general, z is a standard matrix object, however, z can also be a nested matrix object. Either way, increasing row indices represent increasing x values, and increasing column indices represent increasing y values.

Note that all the main plotting functions except plot3d.bar() have a contrast parameter, that allows us to decrease the contrast, if required.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section* {Loading The Packages}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
First, we need to load (and attach) the intoo and barsurf packages.
<<>>=
library (intoo)
library (barsurf)
@

Note that the barsurf package imports the colorspace package.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section* {Heat Maps and Bar Plots}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let's construct a simple matrix (representing cells, or discrete areas).
<<>>=
z1 = outer (1:10, 1:10, "+")
@

And then produce a heat map (in 2D) and a bar plot (in 3D).
\begin {center}
<<fig=TRUE, width=4.75, height=3>>=
plot2d.cell (,,z1)
@
<<fig=TRUE, width=4.75, height=3>>=
plot3d.bar (,,z1, zlim=c (0, 20) )
@
\end {center}

Note the two commas.

Also note that the origin of the 3D plot is at the bottom center.

The cells (or bars) don't have to be the same size. We can specify x and y break points, in which case their lengths should be one more than the dimensions of z, and they should be sorted in ascending order.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section* {Contour Plots and Surface Plots}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let's construct another matrix (but representing points on a surface rather than cells).
<<>>=
x = y = 1:20
f = function (x, y) x ^ 2 + y ^ 2
z2 = outer (x, y, f)
@

And then we can produce a contour plot (in 2D) and a surface plot (in 3D).
\begin {center}
<<fig=TRUE, width=4.75, height=3>>=
plot2d.contour (,,z2)
@
<<fig=TRUE, width=4.75, height=3>>=
plot3d.surface (,,z2)
@
\end {center}

It doesn't have to be a regularly spaced grid. We can specify x and y values, in which case their lengths should equal to the dimensions of z.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section* {Color Conversion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
I've supplied functions for mapping RGB to HCL, and vice versa.

These are just wrappers for functions in the colorspace package, however, they map a vector to a vector, rather than a color object to a color object.

<<>>=
colv.1.rgb = c (1, 0, 0)
colv.1.hcl = rgb2hcl (colv.1.rgb)
round (colv.1.hcl, 2)
@

<<>>=
colv.2.hcl = c (0, 50, 60)
colv.2.rgb = hcl2rgb (colv.2.hcl)
round (colv.2.rgb, 2)
@

By default, the hcl2rgb() function, corrects the RGB values, if they're not in the interval [0, 1].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section* {Changing Colors}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Currently, there are three ways to change the colors:
\begin {enumerate}
	\item Use the use.theme() function.
	\item Set global options, directly.
	\item Specify color arguments (mainly, colv.1 and colv.2), in each function call.
\end {enumerate}

We can set the theme by either:
\begin {center}
<<fig=TRUE, width=4.75, height=4>>=
use.theme ("blue")
test.theme ()
@
<<fig=TRUE, width=4.75, height=4>>=
use.theme ("green")
test.theme ()
@
\end {center}

<<echo=FALSE>>=
use.theme ("blue")
@

Global options are stored in a list named barsurf.
<<>>=
bso = getOption ("barsurf")
bso
@

<<>>=
bso$plot2d.cell.colv.1 = c (90, 45, 65)
bso$plot2d.cell.colv.2 = c (360, 45, 65)
@

<<>>=
options (barsurf=bso)
@

\begin {center}
<<fig=TRUE, width=4.75, height=3>>=
plot2d.cell (,,z1)
@
\end {center}

<<echo=FALSE>>=
use.theme ("blue")
@

Note that in this section, I've omitted some R input which resets the theme to blue.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section* {Triangular Plots}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In triangular plots, the matrix must be square, and only upper left part of the matrix (including the diagonal) is used.

Let's create another matrix.
<<>>=
x = y = -9:10
f = function (x, y) 200 - (x ^ 2 + y ^ 2)
z3 = outer (x, y, f)
@

I'm going to set the lower right part of the matrix to NAs to make it obvious what's happening here, however, this step is unnecessary.
<<>>=
z3 = lr2na (z3)
P.ht (z3)
@

And plot them.
\begin {center}
<<fig=TRUE, width=4.75, height=3>>=
plot2d.tricontour (,,z3)
@
<<fig=TRUE, width=4.75, height=3>>=
plot3d.trisurface (,,z3)
@
\end {center}

Note that in plot3d.trisurface(), the x and y arguments are ignored.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section* {Nested Matrices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
My other package, intoo, contains early prototypes for nested matrices, which can be used for grouped heat maps and grouped bar plots.

Let's create a nested matrix object.
<<>>=
z4 = outer (1:8, 1:8, "+")
@

<<>>=
sm.1 = P.smatrix (1, 2, 1, 2)
sm.2 = P.smatrix (1, 4, 1, 4)
sm.3 = P.smatrix (1, 6, 1, 6)
sm.4 = P.smatrix (1, 8, 1, 8)
@

<<>>=
z4 = P.nmatrix (z4, list (sm.1, sm.2, sm.3, sm.4) )
@

<<>>=
z4
@

\begin {center}
<<fig=TRUE, width=4.75, height=3>>=
plot2d.cell (,,z4)
@

<<fig=TRUE, width=4.75, height=3>>=
plot3d.bar (,,z4, zlim=c (0, 16), colv.2=c (0, 0, 80), reverse=TRUE)
@
\end {center}

\end{document}
